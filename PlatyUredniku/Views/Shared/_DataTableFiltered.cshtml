@using System.Reflection
@using System.Text.Json
@using PlatyUredniku.DataTable

@model DataTableFilter

@{
  // ===== Columns & sorting meta =====
  var items = (Model.InitialData as System.Collections.IEnumerable)?.Cast<object>().ToList() ?? new List<object>();
  var rowType = items.FirstOrDefault()?.GetType();

  var visibleProps = new List<(PropertyInfo Prop, HtmlTableDefinition.ColumnAttribute? Attr)>();
  if (rowType != null)
  {
    foreach (var p in rowType.GetProperties(BindingFlags.Instance | BindingFlags.Public))
    {
      var attr = p.GetCustomAttribute<HtmlTableDefinition.ColumnAttribute>();
      var isHiddenAttr = attr?.Type == HtmlTableDefinition.ColumnType.Hidden;
      var isHiddenByName = p.Name.EndsWith("_Sort", StringComparison.Ordinal);
      if (!isHiddenAttr && !isHiddenByName)
        visibleProps.Add((p, attr));
    }
  }

  // Build hidden sort siblings ONCE and map visibleIndex -> hiddenDtIndex
  var hiddenSortProps = new List<PropertyInfo>();
  var sortIndexMap = new Dictionary<int, int>(); // visible idx -> DT absolute idx of hidden column

  if (rowType != null)
  {
    for (int i = 0; i < visibleProps.Count; i++)
    {
      var sortName = visibleProps[i].Prop.Name + "_Sort";
      var sortProp = rowType.GetProperty(sortName, BindingFlags.Instance | BindingFlags.Public);
      if (sortProp != null)
      {
        var existing = hiddenSortProps.FindIndex(p => p.Name == sortProp.Name);
        if (existing < 0)
        {
          hiddenSortProps.Add(sortProp);
          existing = hiddenSortProps.Count - 1;
        }

        sortIndexMap[i] = visibleProps.Count + existing; // hidden columns are appended after visible ones
      }
    }
  }

// Targets by type (only visible columns)
  var numberIdxTargets = visibleProps
    .Select((x, i) => new { x, i })
    .Where(t => t.x.Attr?.Type == HtmlTableDefinition.ColumnType.Number)
    .Select(t => t.i)
    .ToArray();

  var priceIdxTargets = visibleProps
    .Select((x, i) => new { x, i })
    .Where(t => t.x.Attr?.Type == HtmlTableDefinition.ColumnType.Price)
    .Select(t => t.i)
    .ToArray();

  string Camel(string n) => JsonNamingPolicy.CamelCase.ConvertName(n);

// Build DataTables columns:
// - First, all visible columns with orderData pointing to their hidden sort sibling (if any), then fallback to self
  var dtColumnsVisible = visibleProps.Select((vp, i) => new
  {
    data = Camel(vp.Prop.Name),
    name = Camel(vp.Prop.Name),
    orderData = sortIndexMap.TryGetValue(i, out var hidIdx)
      ? new[] { hidIdx, i } // primary: hidden sorter, secondary: itself
      : new[] { i }
  });

// - Then append hidden sort columns (these must exist in DT columns to be addressable by orderData)
  var dtColumnsHidden = hiddenSortProps.Select(p => new
  {
    data = Camel(p.Name),
    name = Camel(p.Name),
    visible = false,
    searchable = false
  });

  var dtColumns = dtColumnsVisible.Concat<object>(dtColumnsHidden).ToList();

// Header titles for visible columns
  string HeaderTitle((PropertyInfo Prop, HtmlTableDefinition.ColumnAttribute? Attr) c)
    => c.Attr?.Name ?? c.Prop.Name;
}
<style>
  #filterAccordion .accordion-button:not(.collapsed) {
    background-color: transparent !important;
    color: inherit;
    box-shadow: none;
  }
</style>

<div class="row">
  @* Filter *@
  <div class="col-2">
    <form id="@Model.FormId" class="my-4">
      <div class="accordion" id="filterAccordion">
        @{
          var idx = 0;
          foreach (var filter in Model.Filters)
          {
            var paneId = $"filterPane{idx++}";
            <div class="accordion-item">
              <h2 class="accordion-header" id="heading-@paneId">
                <button class="accordion-button collapsed" type="button"
                        data-bs-toggle="collapse" data-bs-target="#collapse-@paneId"
                        aria-expanded="false" aria-controls="collapse-@paneId">
                  @filter.Label
                </button>
              </h2>
              <div id="collapse-@paneId" class="accordion-collapse collapse" aria-labelledby="heading-@paneId">
                <div class="accordion-body">
                  @filter.Render()
                </div>
              </div>
            </div>
          }
        }
      </div>
      @Model.RenderResetButton()
    </form>
  </div>
  
  @* DataTable *@
  <div class="col-10">
    <table id="@Model.TableId" class="table table-striped table-bordered">
      <thead>
      <tr>
        @foreach (var col in visibleProps)
        {
          <th>@HeaderTitle(col)</th>
        }
      </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script>
  $(function () {
    const dtColumns = @Html.Raw(JsonSerializer.Serialize(dtColumns, JsonSerializerOptions.Web));
    const numberIdxTargets = @Html.Raw(JsonSerializer.Serialize(numberIdxTargets, JsonSerializerOptions.Web));
    const priceIdxTargets = @Html.Raw(JsonSerializer.Serialize(priceIdxTargets, JsonSerializerOptions.Web));
    const initialData = @Html.Raw(JsonSerializer.Serialize(Model.InitialData, JsonSerializerOptions.Web));

    const baseColumnDefs = [
      {targets: numberIdxTargets, className: 'number', type: 'num'},
      {
        targets: priceIdxTargets,
        className: 'number',
        type: 'num',
        render: function (data, type) {
          const n = (typeof data === 'number') ? data : parseFloat(String(data ?? '').replace(/\s|[^\d.-]/g, ''));
          if (type === 'sort' || type === 'type' || type === 'filter') return isNaN(n) ? null : n;
          if (isNaN(n)) return '';
          return new Intl.NumberFormat('cs-CZ', {
            style: 'currency',
            currency: 'CZK',
            minimumFractionDigits: 0,
            maximumFractionDigits: 0
          }).format(n);
        }
      }
    ];

    const table = $('#@Model.TableId').DataTable({
      data: initialData ?? [],
      columns: dtColumns,             // includes hidden sort columns
      columnDefs: baseColumnDefs,     // no more sortColumnDefs needed
      language: {'url': '//cdn.datatables.net/plug-ins/1.13.4/i18n/cs.json'},
      lengthChange: false,
      info: false,
      order: @Html.Raw(Model.DefaultOrder),
      pageLength: 25
    });

    const form = $('#@Model.FormId');

    function debounce(fn, delay) {
      let t;
      return function (...args) {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    let inflight = null;
    const fetchAndRender = debounce(function () {
      if (inflight) inflight.abort();
      inflight = $.ajax({
        url: '@Model.DataEndpointUrl',
        method: 'GET',
        data: form.serialize()
      }).done(data => {
        table.clear().rows.add(data).draw();
      }).always(() => {
        inflight = null;
      });
    }, 200);

    form.off('.filters');
    form.on('submit.filters', e => e.preventDefault());
    form.on('change.filters', 'input[type=radio], input[type=checkbox], select', function () {
      if (this.type === 'radio' && !this.checked) return;
      fetchAndRender();
    });
    form.on('input.filters', 'input[type=number], input[type=range], input[type=text], input[type=search]', fetchAndRender);

    $('#resetFiltersButton').on('click', function() {
      const initialValues = JSON.parse($(this).attr('data-init'));

      for (const key in initialValues) {
        const value = initialValues[key];

        // Resetování ChoiceFilterField (radio, checkbox)
        if (Array.isArray(value)) {
          // Checkboxy
          if ($(`input[name="${key}"][type="checkbox"]`).length > 0) {
            $(`input[name="${key}"][type="checkbox"]`).prop('checked', false);
            value.forEach(v => {
              $(`input[name="${key}"][value="${v}"]`).prop('checked', true);
            });
          }
          // Radio buttony
          else if ($(`input[name="${key}"][type="radio"]`).length > 0) {
            $(`input[name="${key}"][value="${value[0]}"]`).prop('checked', true);
          }
        }
        // Resetování TextFilterField a RangeFilterField
        else {
          $(`input[name="${key}"]`).val(value);
        }
      }

      // Aktualizace tabulky po resetování
      fetchAndRender();
    });
  });
</script>