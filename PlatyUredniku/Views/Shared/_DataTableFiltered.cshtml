@using System.Reflection
@using System.Text.Json
@using PlatyUredniku.DataTable

@model DataTableFilter

@{
  // ===== Columns & sorting meta =====
  var items = (Model.InitialData as System.Collections.IEnumerable)?.Cast<object>().ToList() ?? new List<object>();
  var rowType = items.FirstOrDefault()?.GetType();

  var visibleProps = new List<(PropertyInfo Prop, HtmlTableDefinition.ColumnAttribute? Attr)>();
  if (rowType != null)
  {
    foreach (var p in rowType.GetProperties(BindingFlags.Instance | BindingFlags.Public))
    {
      var attr = p.GetCustomAttribute<HtmlTableDefinition.ColumnAttribute>();
      var isHiddenAttr = attr?.Type == HtmlTableDefinition.ColumnType.Hidden;
      var isHiddenByName = p.Name.EndsWith("_Sort", StringComparison.Ordinal);
      if (!isHiddenAttr && !isHiddenByName)
        visibleProps.Add((p, attr));
    }
  }

  // Build hidden sort siblings ONCE and map visibleIndex -> hiddenDtIndex
  var hiddenSortProps = new List<PropertyInfo>();
  var sortIndexMap = new Dictionary<int, int>(); // visible idx -> DT absolute idx of hidden column

  if (rowType != null)
  {
    for (int i = 0; i < visibleProps.Count; i++)
    {
      var sortName = visibleProps[i].Prop.Name + "_Sort";
      var sortProp = rowType.GetProperty(sortName, BindingFlags.Instance | BindingFlags.Public);
      if (sortProp != null)
      {
        var existing = hiddenSortProps.FindIndex(p => p.Name == sortProp.Name);
        if (existing < 0)
        {
          hiddenSortProps.Add(sortProp);
          existing = hiddenSortProps.Count - 1;
        }

        sortIndexMap[i] = visibleProps.Count + existing; // hidden columns are appended after visible ones
      }
    }
  }

// Targets by type (only visible columns)
  var numberIdxTargets = visibleProps
    .Select((x, i) => new { x, i })
    .Where(t => t.x.Attr?.Type == HtmlTableDefinition.ColumnType.Number)
    .Select(t => t.i)
    .ToArray();

  var priceIdxTargets = visibleProps
    .Select((x, i) => new { x, i })
    .Where(t => t.x.Attr?.Type == HtmlTableDefinition.ColumnType.Price)
    .Select(t => t.i)
    .ToArray();

  string Camel(string n) => JsonNamingPolicy.CamelCase.ConvertName(n);

// Build DataTables columns:
// - First, all visible columns with orderData pointing to their hidden sort sibling (if any), then fallback to self
  var dtColumnsVisible = visibleProps.Select((vp, i) => new
  {
    data = Camel(vp.Prop.Name),
    name = Camel(vp.Prop.Name),
    orderData = sortIndexMap.TryGetValue(i, out var hidIdx)
      ? new[] { hidIdx, i } // primary: hidden sorter, secondary: itself
      : new[] { i }
  });

// - Then append hidden sort columns (these must exist in DT columns to be addressable by orderData)
  var dtColumnsHidden = hiddenSortProps.Select(p => new
  {
    data = Camel(p.Name),
    name = Camel(p.Name),
    visible = false,
    searchable = false
  });

  var dtColumns = dtColumnsVisible.Concat<object>(dtColumnsHidden).ToList();

// Header titles for visible columns
  string HeaderTitle((PropertyInfo Prop, HtmlTableDefinition.ColumnAttribute? Attr) c)
    => c.Attr?.Name ?? c.Prop.Name;
}
<style>
  #filterAccordion .accordion-button:not(.collapsed) {
    background-color: transparent !important;
    color: inherit;
    box-shadow: none;
  }
</style>

<div class="row">
  @* Filter *@
  <div class="col-2">
    <form id="@Model.FormId" class="my-4">
      <div class="accordion" id="filterAccordion">
        @{
          var idx = 0;
          foreach (var filter in Model.Filters)
          {
            var paneId = $"filterPane{idx++}";

            <div class="accordion-item" style="@(filter.Hidden ? "display:none" : "")">
              <h2 class="accordion-header" id="heading-@paneId">
                <button class="accordion-button collapsed" type="button"
                        data-bs-toggle="collapse" data-bs-target="#collapse-@paneId"
                        aria-expanded="false" aria-controls="collapse-@paneId">
                  @filter.Label
                </button>
              </h2>
              <div id="collapse-@paneId" class="accordion-collapse collapse" aria-labelledby="heading-@paneId">
                <div class="accordion-body">
                  @filter.Render()
                </div>
              </div>
            </div>
          }
        }
      </div>
      @Model.RenderResetButton()
    </form>
  </div>

  @* DataTable *@
  <div class="col-10">
    <div class="filters">
      
    </div>
    <table id="@Model.TableId" class="table table-striped table-bordered">
      <thead>
      <tr>
        @foreach (var col in visibleProps)
        {
          <th>@Html.Raw(HeaderTitle(col))</th>
        }
      </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script>
  $(function () {
    const tableId = '@Model.TableId';
    const formId = '@Model.FormId';
    const dataEndpointUrl = '@Model.DataEndpointUrl';
    
    const dtColumns = @Html.Raw(JsonSerializer.Serialize(dtColumns, JsonSerializerOptions.Web));
    const numberIdxTargets = @Html.Raw(JsonSerializer.Serialize(numberIdxTargets, JsonSerializerOptions.Web));
    const priceIdxTargets = @Html.Raw(JsonSerializer.Serialize(priceIdxTargets, JsonSerializerOptions.Web));
    const initialData = @Html.Raw(JsonSerializer.Serialize(Model.InitialData, JsonSerializerOptions.Web));
    const initialValues = @Html.Raw(Model.GetInitialValuesJson());
    const filterOptions = @Html.Raw(Model.GetFilterOptionsJson());

    // první render filtrů
    const urlParams = new URLSearchParams(window.location.search);
    const paramsToApply = {};

    for (const [key, value] of urlParams.entries()) {
      if (!paramsToApply[key]) {
        paramsToApply[key] = [];
      }
      paramsToApply[key].push(value);
    }

    for (const key in paramsToApply) {
      const values = paramsToApply[key];
      const input = $(`[name="${key}"]`);

      if (input.is('input[type="radio"], input[type="checkbox"]')) {
        // Nejprve odznačit vše, pak nastavit správné hodnoty
        input.prop('checked', false);
        values.forEach(v => $(`[name="${key}"][value="${v}"]`).prop('checked', true));
      } else if (input.length > 0) {
        // Textové, číselné a select pole
        input.val(values[0]);
      }
    }

    // Jednorázové načtení a uložení mapování labelů
    const fieldLabels = {};
    $('#filterAccordion button.accordion-button').each(function() {
      const label = $(this).text().trim();
      const paneId = $(this).attr('aria-controls');
      const inputName = $(`#${paneId} input, #${paneId} select`).first().attr('name');
      if (inputName) {
        fieldLabels[inputName] = label;
      }
    });

    const baseColumnDefs = [
      {
        targets: numberIdxTargets,
        createdCell: function (td, cellData, rowData, row, col) {
          $(td).addClass('number');
        },
        type: 'num'
      },
      {
        targets: priceIdxTargets,
        createdCell: function (td, cellData, rowData, row, col) {
          $(td).addClass('number');
        },
        type: 'num',
        render: function (data, type) {
          const n = (typeof data === 'number') ? data : parseFloat(String(data ?? '').replace(/\s|[^\d.-]/g, ''));
          if (type === 'sort' || type === 'type' || type === 'filter') return isNaN(n) ? null : n;
          if (isNaN(n)) return '';
          return new Intl.NumberFormat('cs-CZ', {
            style: 'currency',
            currency: 'CZK',
            minimumFractionDigits: 0,
            maximumFractionDigits: 0
          }).format(n);
        }
      }
    ];

    const table = $(`#${tableId}`).DataTable({
      data: initialData ?? [],
      columns: dtColumns,
      columnDefs: baseColumnDefs,
      language: {'url': '//cdn.datatables.net/plug-ins/1.13.4/i18n/cs.json'},
      lengthChange: false,
      info: false,
      order: @Html.Raw(Model.DefaultOrder),
      pageLength: 25
    });

    const form = $(`#${formId}`);
    const filtersContainer = $('.filters');
    let inflight = null;

    function debounce(fn, delay) {
      let t;
      return function (...args) {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    function getNormalizedFormData() {
      const formData = form.serializeArray();
      const result = {};
      formData.forEach(item => {
        if (result[item.name]) {
          if (!Array.isArray(result[item.name])) {
            result[item.name] = [result[item.name]];
          }
          result[item.name].push(item.value);
        } else {
          result[item.name] = item.value;
        }
      });
      return result;
    }

    function isSame(valueA, valueB) {
      if (Array.isArray(valueA) && Array.isArray(valueB)) {
        const setA = new Set(valueA.sort());
        const setB = new Set(valueB.sort());
        if (setA.size !== setB.size) return false;
        return [...setA].every(val => setB.has(val));
      } else {
        return String(valueA) === String(valueB);
      }
    }

    const fetchAndRender = debounce(async function () {
      if (inflight) inflight.abort();

      const currentValues = getNormalizedFormData();
      const filteredData = new URLSearchParams();
      const processedKeys = new Set(); // Sledujeme již zpracované klíče

      for (const key in currentValues) {
        if (!currentValues.hasOwnProperty(key) || processedKeys.has(key)) continue;

        const initial = initialValues[key];
        const current = currentValues[key];

        // Zpracování rozsahu (From/To)
        if (key.endsWith('From')) {
          const baseKey = key.replace('From', '');
          const fromKey = key;
          const toKey = baseKey + 'To';

          processedKeys.add(fromKey);
          processedKeys.add(toKey);

          const isFromChanged = !isSame(initialValues[fromKey], currentValues[fromKey]);
          const isToChanged = !isSame(initialValues[toKey], currentValues[toKey]);

          if (isFromChanged || isToChanged) {
            if (currentValues[fromKey]) filteredData.append(fromKey, currentValues[fromKey]);
            if (currentValues[toKey]) filteredData.append(toKey, currentValues[toKey]);
          }
        }
        // Standardní filtry
        else {
          if (!isSame(initial, current)) {
            if (Array.isArray(current)) {
              current.forEach(v => filteredData.append(key, v));
            } else {
              filteredData.append(key, current);
            }
          }
        }
      }

      const queryString = filteredData.toString();
      const url = `${dataEndpointUrl}?${queryString}`;
      
      //update address bar
      const newUrl = window.location.protocol + "//" + window.location.host + window.location.pathname + (queryString ? `?${queryString}` : '');
      if (newUrl !== window.location.href) {
        history.pushState(null, '', newUrl);
      }

      const controller = new AbortController();
      inflight = controller;

      try {
        const response = await fetch(url, {
          method: 'GET',
          signal: controller.signal
        });
        const data = await response.json();

        table.clear().rows.add(data).draw();
        renderActivePills(currentValues);

      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error("Fetch failed:", error);
        }
      } finally {
        inflight = null;
      }
    }, 200);


    function renderActivePills(currentValues) {
      filtersContainer.empty();
      const activeFilters = new Map();

      // Použijeme Set pro sledování již zpracovaných klíčů (např. 'početPrijmuFrom')
      const processedKeys = new Set();

      for (const key in currentValues) {
        if (!currentValues.hasOwnProperty(key) || processedKeys.has(key)) continue;

        const value = currentValues[key];
        const initial = initialValues[key];

        if (key.endsWith('From')) {
          const baseKey = key.replace('From', '');
          const fromKey = key;
          const toKey = baseKey + 'To';

          processedKeys.add(fromKey);
          processedKeys.add(toKey);

          const isFromChanged = !isSame(initialValues[fromKey], currentValues[fromKey]);
          const isToChanged = !isSame(initialValues[toKey], currentValues[toKey]);

          if (isFromChanged || isToChanged) {
            const label = fieldLabels[fromKey] || baseKey;
            const fromValue = currentValues[fromKey] || '';
            const toValue = currentValues[toKey] || '';
            const displayValue = `${fromValue} - ${toValue}`;
            activeFilters.set(label, displayValue);
          }
        }
        else if (key.endsWith('To')) {
          // Přeskočíme, protože je zpracováno v 'From' bloku
          continue;
        }
        else {
          // Standardní filtry
          if (!isSame(initial, value)) {
            const label = fieldLabels[key] || key;
            let displayValue = value;

            if (filterOptions.hasOwnProperty(key)) {
              const optionsMap = filterOptions[key];
              if (Array.isArray(value)) {
                displayValue = value.map(v => optionsMap[v] || v).join(', ');
              } else {
                displayValue = optionsMap[value] || value;
              }
            }

            const existingValue = activeFilters.get(label);
            if (existingValue) {
              activeFilters.set(label, `${existingValue}, ${displayValue}`);
            } else {
              activeFilters.set(label, displayValue);
            }
          }
        }
      }

      activeFilters.forEach((value, key) => {
        const pill = $(`
          <span class="badge rounded-pill bg-secondary d-inline-flex align-items-center me-2 mb-2" data-name="${key}">
            ${key}: ${value}
            <button type="button" class="btn-close btn-close-white ms-2" aria-label="Close"></button>
          </span>
        `);
        filtersContainer.append(pill);
      });
    }

    // Event listenery
    form.off('.filters');
    form.on('submit.filters', e => e.preventDefault());
    form.on('change.filters', 'input[type=radio], input[type=checkbox], select', fetchAndRender);
    form.on('input.filters', 'input[type=number], input[type=range], input[type=text], input[type=search]', fetchAndRender);

    $('#resetFiltersButton').on('click', function () {
      for (const key in initialValues) {
        const value = initialValues[key];
        const input = $(`[name="${key}"]`);

        if (input.is('input[type="radio"], input[type="checkbox"]')) {
          // Nejprve odškrtneme všechny, pak zaškrtneme ty správné
          $(`[name="${key}"]`).prop('checked', false);
          if (Array.isArray(value)) {
            value.forEach(v => $(`[name="${key}"][value="${v}"]`).prop('checked', true));
          } else if (value !== null) {
            $(`[name="${key}"][value="${value}"]`).prop('checked', true);
          }
        } else {
          // Reset pro textová, číselná atd. pole
          input.val(value);
        }
      }
      fetchAndRender();
    });

    filtersContainer.on('click', '.btn-close', function() {
      const pill = $(this).closest('.badge');
      const pillName = pill.data('name');
      const accordionButton = $(`#filterAccordion button:contains('${pillName}')`);
      const paneId = accordionButton.attr('aria-controls');
      const inputs = $(`#${paneId} input, #${paneId} select`);

      // Obnova hodnot
      inputs.each(function() {
        const inputName = $(this).attr('name');
        const initialValue = initialValues.hasOwnProperty(inputName) ? initialValues[inputName] : null;
        
        if ($(this).is('input[type="radio"], input[type="checkbox"]')) {
           $(this).prop('checked', false);
           if (Array.isArray(initialValue) && initialValue.includes($(this).val())) {
             $(this).prop('checked', true);
           } else if (!Array.isArray(initialValue) && initialValue !== null && $(this).val() === initialValue) {
             $(this).prop('checked', true);
           }
        } else {
          $(this).val(initialValue);
        }
      });
      fetchAndRender();
    });
    
    //bootstrap tooltips (if exist)
    const initTooltips = () => {
      document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(el => {
        if (!bootstrap.Tooltip.getInstance(el)) {
          new bootstrap.Tooltip(el);
        }
      });
    };

    $(`#${tableId}`).on('draw.dt', function () {
      initTooltips();
    });

    // first pill render
    const initialFormState = getNormalizedFormData();
    renderActivePills(initialFormState);
  });
</script>