@page "/Account/Login-Callback/{Token}/{Mhash}"
@using System.Security.Claims
@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.Authentication.Cookies
@using Microsoft.EntityFrameworkCore
@using PoliticiEditor.Data

@inject NavigationManager NavigationManager
@inject PoliticiLoginsDbContext DbContext
@inject IHttpContextAccessor HttpContextAccessor

<h1>Přihlašuju...</h1>

@code {
    
    [Parameter]
    public string Token { get; set; }
    [Parameter]
    public string Mhash { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        var user = await DbContext.PoliticiEditorUsers
            .FirstOrDefaultAsync(u => u.EmailHash == Mhash);
        
        if (user is null || user.IsApproved == false)
        {
            NavigationManager.NavigateTo("/Account/AccessDenied", forceLoad: true);
            return;
        }
        
        var loginToken = await DbContext.PoliticiLoginTokens
            .FirstOrDefaultAsync(t => t.Token == Token && !t.Used && t.ExpiresAt > DateTime.Now && t.UserId == user.Id);

        if (loginToken == null)
        {
            NavigationManager.NavigateTo("/Account/AccessDenied", forceLoad: true);
            return;
        }

        loginToken.Used = true;
        await DbContext.SaveChangesAsync();

        var claims = user.CreateClaims();

        var identity = new ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme);
        var principal = new ClaimsPrincipal(identity);
        
        await HttpContextAccessor.HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, principal);
        await Task.Delay(300);
        //We need to let cookie properly sit, so we have to redirect twice!
        NavigationManager.NavigateTo("/Account/Login-Redirect", forceLoad: true);

    }

    // protected override async Task OnAfterRenderAsync(bool firstRender)
    // {
    //     await JS.InvokeVoidAsync("eval", "window.location.href = '/'");
    // }

}