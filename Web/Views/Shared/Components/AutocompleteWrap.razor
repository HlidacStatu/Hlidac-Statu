@using HlidacStatu.Entities
@using System.Threading
@using System.Text.Json
@using HlidacStatu.Util
@using Microsoft.AspNetCore.Http
@using Microsoft.AspNetCore.WebUtilities

@inject NavigationManager Navigation

<style>
    .hlidac-autocomplete {
        /*border: 2px solid yellow;   */         
        position:relative;
        padding:0;
        margin:0;
    }

    .hlidac-autocomplete .hlidac-autocomplete-list {
        /*border: 1px solid red;*/
        position:absolute;
        left:0px;
        z-index:100;
        width:80%;
        margin: 0;
        padding: 0;
    }
    
    .no-overflow {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    
    .selected-element {
        max-width: 200px;
    }
    
    .input-group-newline {
        width: 100%;
    }
    
    .hs-avatar {
        float: left;
        width: 50px;
        height: auto;
        margin-right: 10px;
        color: #ccc;
        position: relative;
        font-size: 45px;
    }
    
    .hs-avatar img {
        width: 50px;
        vertical-align: top;
    }
    
    .hs-autocomplete-description {
        margin-left: 70px;
        
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    
    
    #components-reconnect-modal,
    #components-reconnect-modal.components-reconnect-show {
        display: none;
    }
    
     
    #components-reconnect-modal.components-reconnect-failed, 
    #components-reconnect-modal.components-reconnect-rejected {
        display: block;
    }
    
    
    
</style>

<ErrorBoundary>
    <ChildContent>
        <HlidacAutocompleteMultitag SearchFuncAsync="@((s, token) => OnSearch(s, token))"
                                    OnAutocompleteSubmitted="@(OnAutocompleteSubmitted)"
                                    TextSelector="@((autocomplete) => autocomplete.Text)"
                                    InputTags="InputTags"
                                    TItem="Autocomplete">
            <TagTemplate>
                @if (context.Value is null)
                {
                    <span style="overflow:hidden; text-overflow:ellipsis;">@context.Text</span>
                }
                else
                {
                    <span style="overflow:hidden; text-overflow:ellipsis;">@(CategoryToPicture(context.Value.Category))&nbsp;@context.Value.Text</span>
                }
            </TagTemplate>
            <ItemTemplate>
                <div>
                    <div class="hs-avatar">
                        @((MarkupString)context.ImageElement)
                    </div>
                    <div class="hs-autocomplete-description">
                        
                        <h6 class="fw-bold">@context.Text</h6>
                        <small>@context.Description</small>
                        <br/>
                        <small class="text-muted"><i>@context.Type</i></small>
                    </div>
                </div>

            </ItemTemplate>
        </HlidacAutocompleteMultitag>
    </ChildContent>
    <ErrorContent>
        <div class="hlidac-autocomplete mb-3">
            <div class="input-group">
                <input type="text"
                       autocomplete="off"
                       placeholder="Došlo k neočekávané chybě. Načtěte prosím stránku znovu"
                       class="hlidac-autocomplete-input form-control"
                       disabled="disabled"/>

                <a class="btn btn-primary" href="javascript:window.location.reload()" style="margin-bottom:0;margin-top:0;padding-bottom:0">
                    Načíst znovu
                </a>
            </div>
        </div>
    </ErrorContent>
</ErrorBoundary>

<div id="components-reconnect-modal">
    <a class="btn btn-primary" href="javascript:window.location.reload()" style="margin-bottom:0;margin-top:0;padding-bottom:0">
        Došlo k chybě připojení. Chcete-li používat vyhledávací okno, načtěte znovu tuto stránku.
    </a>
</div>



@code {

    [Parameter]
    public string Endpoint { get; set; }

    [Parameter]
    public HttpClient HttpClient { get; set; }
    
    [Parameter]
    public string SearchPath { get; set; }

    private List<string>? InputTags { get; set; }
    
    
    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        
        var uri = Navigation.ToAbsoluteUri(Navigation.Uri);
        if (QueryHelpers.ParseQuery(uri.Query).TryGetValue("q", out var q) &&
            QueryHelpers.ParseQuery(uri.Query).TryGetValue("qtl", out var qtl))
        {
            InputTags = ParseTools.ParseQueryStringWithOffsets(q, qtl);
        }
        
    }


    private async Task<List<Autocomplete>> OnSearch(string query, CancellationToken cancellationToken)
    {
        JsonSerializerOptions? _jsonSerializerOptions = new()
        {
            PropertyNameCaseInsensitive = true
        };

        var autocompletePath = $"/autocomplete/autocomplete?q={query}";

        var uri = new Uri($"{Endpoint}{autocompletePath}");
    // using var client = HttpClientFactory.CreateClient();
    //using var client = new HttpClient();

        try
        {
            using var response = await HttpClient.GetAsync(uri, cancellationToken);

            _ = response.EnsureSuccessStatusCode();


            var datastream = await response.Content.ReadAsStreamAsync(cancellationToken);

            var autocomplete = await JsonSerializer.DeserializeAsync<List<Autocomplete>>(datastream,
                cancellationToken: cancellationToken,
                options: _jsonSerializerOptions);

            return autocomplete ?? Enumerable.Empty<Autocomplete>().ToList();
        }
        catch (Exception ex) when (ex is OperationCanceledException || ex is TaskCanceledException)
        {
    // canceled by user
        }
        catch (Exception e)
        {
    //log exception?
        }

        return Enumerable.Empty<Autocomplete>().ToList();
    }

    private Task OnAutocompleteSubmitted(List<AutocompleteItem<Autocomplete>> autocomplete)
    {
        //string qs = string.Join(" ", );
        (string qs, string qtl) = ParseTools.CreateQueryWithOffsets(
            autocomplete.Select(i => i.Value?.Id ?? i.Text ?? "").ToList());

        string url = $"{Navigation.BaseUri}{SearchPath}?q={qs}&qtl={qtl}";
        Navigation.NavigateTo(url, true);

        return Task.CompletedTask;
    }

    private RenderFragment CategoryToPicture(Autocomplete.CategoryEnum categoryEnum) => categoryEnum switch
    {
        Autocomplete.CategoryEnum.Company => @<i class='fas fa-industry-alt fa-xs text-muted'></i>,
        Autocomplete.CategoryEnum.StateCompany => @<i class='fas fa-industry-alt fa-xs text-muted'></i>,
        Autocomplete.CategoryEnum.Authority => @<i class='fas fa-university fa-xs text-muted'></i>,
        Autocomplete.CategoryEnum.City => @<i class='fas fa-city fa-xs text-muted'></i>,
        Autocomplete.CategoryEnum.Person => @<i class="fa-duotone fa-user-secret fa-xs text-muted"></i>,
        Autocomplete.CategoryEnum.Operator => @<i class="fa-solid fa-circle-small fa-xs text-muted"></i>,
        Autocomplete.CategoryEnum.Synonym => @<i class="fa-regular fa-hashtag fa-xs text-muted"></i>,
        Autocomplete.CategoryEnum.Oblast => @<i class="fa-regular fa-tag fa-xs text-muted"></i>,
        _ => @<i class="fa-regular fa-alien-8bit"></i>
        };


}